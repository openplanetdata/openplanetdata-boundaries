name: Aggregate Boundaries Metadata

on:
  workflow_call:
    secrets:
      R2INDEX_API_URL:
        required: true
      R2INDEX_API_TOKEN:
        required: true
      R2_ACCESS_KEY_ID:
        required: true
      R2_SECRET_ACCESS_KEY:
        required: true
      R2_ENDPOINT_URL:
        required: true
      R2_BUCKET:
        required: true
  workflow_dispatch:
  workflow_run:
    workflows:
      - Continent Boundary
      - Country Boundary
      - Planet Coastline
    types: [completed]
    branches: [main]

permissions:
  actions: read
  contents: read

jobs:
  aggregate:
    runs-on: self-hosted

    steps:
      - name: Install required tools
        shell: bash
        run: |
          set -euo pipefail
          need_install() { ! command -v "$1" >/dev/null 2>&1; }

          pkgs=()
          need_install jq && pkgs+=(jq)

          if [ ${#pkgs[@]} -eq 0 ]; then
            echo "All required packages already present."
            exit 0
          fi

          if command -v dnf >/dev/null 2>&1; then
            sudo dnf -y install "${pkgs[@]}"
          elif command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update -qq
            sudo apt-get install -y "${pkgs[@]}"
          else
            echo "Unsupported package manager. Install ${pkgs[*]} manually." >&2
            exit 1
          fi

      - name: Install Python dependencies
        shell: bash
        run: |
          python3 -m pip install --user elaunira-r2index

      - name: Aggregate metadata from r2index API
        env:
          R2INDEX_API_URL: ${{ secrets.R2INDEX_API_URL }}
          R2INDEX_API_TOKEN: ${{ secrets.R2INDEX_API_TOKEN }}
        shell: bash
        run: |
          python3 << 'AGGREGATE_SCRIPT'
          import json
          import os
          from elaunira.r2index import R2IndexClient

          client = R2IndexClient(
              api_url=os.environ["R2INDEX_API_URL"],
              api_token=os.environ["R2INDEX_API_TOKEN"],
          )

          # Single API call to get all file metadata
          print("Fetching file index from r2index API...")
          entries = client.get_index()
          print(f"Found {len(entries)} files")

          # Convert to aggregated metadata format
          aggregated = []
          for entry in entries:
              # Determine format from filename
              filename = entry.remote_filename
              if filename.endswith(".geojson"):
                  format_ext = "geojson"
              elif filename.endswith(".gpkg"):
                  format_ext = "gpkg"
              elif filename.endswith(".parquet"):
                  format_ext = "parquet"
              else:
                  format_ext = filename.rsplit(".", 1)[-1] if "." in filename else "unknown"

              metadata = {
                  "category": entry.category,
                  "entity": entry.entity,
                  "format": format_ext,
                  "id": entry.id,
                  "md5": entry.md5,
                  "name": entry.name,
                  "remote_filename": entry.remote_filename,
                  "remote_path": entry.remote_path,
                  "remote_version": entry.remote_version,
                  "sha1": entry.sha1,
                  "sha256": entry.sha256,
                  "sha512": entry.sha512,
                  "size": entry.size,
                  "tags": entry.tags,
              }
              aggregated.append(metadata)

          # Sort by category, entity, format
          aggregated.sort(
              key=lambda x: (
                  x.get("category", ""),
                  x.get("entity", ""),
                  x.get("format", ""),
                  x.get("remote_filename", ""),
              )
          )

          # Sort keys within each entry
          sorted_aggregated = [dict(sorted(entry.items())) for entry in aggregated]

          with open("boundaries.metadata", "w") as f:
              json.dump(sorted_aggregated, f, indent=2)

          client.close()

          print(f"Aggregated {len(sorted_aggregated)} metadata entries")
          print("Preview:")
          print(json.dumps(sorted_aggregated[:3], indent=2))
          AGGREGATE_SCRIPT

      - name: Upload aggregated metadata to R2
        env:
          R2INDEX_API_URL: ${{ secrets.R2INDEX_API_URL }}
          R2INDEX_API_TOKEN: ${{ secrets.R2INDEX_API_TOKEN }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT_URL }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
        shell: bash
        run: |
          python3 << 'UPLOAD_SCRIPT'
          import os
          from elaunira.r2index import R2Config, R2IndexClient

          r2_config = R2Config(
              access_key_id=os.environ["R2_ACCESS_KEY_ID"],
              secret_access_key=os.environ["R2_SECRET_ACCESS_KEY"],
              endpoint_url=os.environ["R2_ENDPOINT_URL"],
              bucket=os.environ["R2_BUCKET"],
          )

          client = R2IndexClient(
              api_url=os.environ["R2INDEX_API_URL"],
              api_token=os.environ["R2INDEX_API_TOKEN"],
              r2_config=r2_config,
          )

          print("Uploading boundaries.metadata to R2...")
          record = client.upload_and_register(
              file_path="boundaries.metadata",
              category="metadata",
              entity="boundaries",
              remote_path="/boundaries",
              remote_filename="boundaries.metadata",
              remote_version="",
              tags=["metadata", "index", "boundaries"],
          )

          client.close()
          print(f"Uploaded: {record.id}")
          UPLOAD_SCRIPT

      - name: Cleanup
        if: always()
        shell: bash
        run: |
          rm -f boundaries.metadata
